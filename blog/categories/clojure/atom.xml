<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | Squid's Blog]]></title>
  <link href="http://gigasquid.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://gigasquid.github.io/"/>
  <updated>2014-11-10T10:02:33-05:00</updated>
  <id>http://gigasquid.github.io/</id>
  <author>
    <name><![CDATA[Carin Meier]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Green Eggs and Transducers]]></title>
    <link href="http://gigasquid.github.io/blog/2014/09/06/green-eggs-and-transducers/"/>
    <updated>2014-09-06T15:47:00-04:00</updated>
    <id>http://gigasquid.github.io/blog/2014/09/06/green-eggs-and-transducers</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="http://upload.wikimedia.org/wikipedia/en/c/c2/Greenegg.gif">http://upload.wikimedia.org/wikipedia/en/c/c2/Greenegg.gif</a>"></p>

<p>A quick tour of Clojure Transducers with core.async with Dr. Seuss as a guide.</p>

<p>Follow along at home by:</p>

<ul>
<li><code>lein new green-eggs</code></li>
<li>modify your project.clj to include the following:
<code>clojure
(defproject green-eggs "0.1.0-SNAPSHOT"
:description "try them"
:url "http://en.wikipedia.org/wiki/Green_Eggs_and_Ham"
:license {:name "Eclipse Public License"
          :url "http://www.eclipse.org/legal/epl-v10.html"}
:dependencies [[org.clojure/clojure "1.7.0-alpha1"]
               [org.clojure/core.async "0.1.338.0-5c5012-alpha"]])
</code></li>
<li>Start up a repl and hack in!</li>
</ul>


<h2>Green Eggs and Ham</h2>

<p>Transducers are a new feature of Clojure 1.7.  Instead of trying to explain them with words, let&rsquo;s take a look of them in action.  First we need some data.  Let&rsquo;s def a vector of all the places you could try green eggs and ham.</p>

<p>```clojure
(ns green-eggs.core
  (:require [clojure.core.async :as async]))</p>

<p>(def green-eggs-n-ham
  [&ldquo;in the rain&rdquo;
   &ldquo;on a train&rdquo;
   &ldquo;in a box&rdquo;
   &ldquo;with a fox&rdquo;
   &ldquo;in a house&rdquo;
   &ldquo;with a mouse&rdquo;
   &ldquo;here or there&rdquo;
   &ldquo;anywhere&rdquo;])
```</p>

<p>Next, let&rsquo;s create a function that will transform the places into a &ldquo;I would not eat them &hellip;&rdquo; sentence.</p>

<p>```clojure
(defn i-do-not-like-them [s]
  (format &ldquo;I would not eat them %s.&rdquo; s))</p>

<p>(i-do-not-like-them &ldquo;in the rain&rdquo;)
;; &ndash;> &ldquo;I would not eat them in the rain.&rdquo;
```</p>

<p>We also need a function to take this result and actually try the green eggs and ham.</p>

<p>```clojure
(defn try-them [s]
  (clojure.string/replace s  #&ldquo; not&rdquo; &ldquo;&rdquo;))</p>

<p>(try-them &ldquo;I would not eat them in the rain.&rdquo;)
;; &ndash;> &ldquo;I would eat them in the rain.&rdquo;
```</p>

<p>Now we have two transformations that we can apply to the vector of green-eggs-n-ham strings.
One of the really nice things about transducers is that you can describe and compose this transformation without a data structure present.</p>

<p><code>clojure
(def sam-i-am-xform
  (comp
   (map i-do-not-like-them)
   (map try-them)))
</code></p>

<p>We can run the transformation of the transducers against the data in a few ways.</p>

<ul>
<li><em>into</em>: Non-lazy turn the transformation into a collection</li>
<li><em>sequence</em>: Same thing but lazy</li>
<li><em>transduce</em>: Acts like reduce on the all the transformed elements</li>
<li>With <em>core.async</em> channels doing the transformations.</li>
</ul>


<p>Let&rsquo;s look at the green eggs and ham example for each one of these ways:</p>

<h3>Into</h3>

<p>Into takes a transducer and collection to work on and returns the vector we asked for:</p>

<p><code>clojure
(into [] sam-i-am-xform green-eggs-n-ham)
;; -&gt; ["I would eat them in the rain."
;;     "I would eat them on a train."
;;     "I would eat them in a box."
;;     "I would eat them with a fox."
;;     "I would eat them in a house."
;;     "I would eat them with a mouse."
;;     "I would eat them here or there."
;;     "I would eat them anywhere."]
</code></p>

<h3>Sequence</h3>

<p>Sequence takes similar arguments, but as promised, returns a lazy sequence that we can interact with.</p>

<p>```clojure
(class (sequence sam-i-am-xform green-eggs-n-ham))
;; &ndash;> clojure.lang.LazyTransformer</p>

<p>(take 1 (sequence sam-i-am-xform green-eggs-n-ham))
;; &ndash;> (&ldquo;I would eat them in the rain.&rdquo;)</p>

<p>```</p>

<h3>Transduce</h3>

<p>If we want to finally arrange all our sentences in the vectors into one string, we would use reduce.  The way to do this with transducers is to use <em>transduce</em>.  It takes a function of two arguments to perform the reduce, as well as an initial data input.</p>

<p>```clojure
(transduce sam-i-am-xform #(str %1 %2 &ldquo; &rdquo;) &ldquo;&rdquo; green-eggs-n-ham)
;; &ndash;> &ldquo;I would eat them in the rain.
;;     I would eat them on a train.
;;     I would eat them in a box.
;;     I would eat them with a fox.
;;     I would eat them in a house.
;;     I would eat them with a mouse.
;;     I would eat them here or there.
;;     I would eat them anywhere.&rdquo;</p>

<p>;;_note: In  1.7.0-alpha2, transduce changed and you need to use a
;;(transduce sam-i-am-xform (completing #(str %1 %2 &ldquo; &rdquo;)) &ldquo;&rdquo; green-eggs-n-ham)
;;instead.</p>

<p>```</p>

<h3>Core.async</h3>

<p>Core.async has a really nice way to define channels with a transducer that will transform each element on the channel.</p>

<p><code>clojure
(def sam-i-am-chan (async/chan 1 sam-i-am-xform))
</code></p>

<p>Let&rsquo;s define another channel to reduce the results of the sam-i-am-chan to a string.</p>

<p><code>clojure
(def result-chan (async/reduce #(str %1 %2 " ") "" sam-i-am-chan))
</code></p>

<p>Finally, let&rsquo;s actually put the green-eggs-n-ham data onto the sam-i-am-chan and let the data transformations flow&hellip;.</p>

<p><code>clojure
(async/onto-chan sam-i-am-chan green-eggs-n-ham)
</code></p>

<p>At last,
we can get our result off the result channel and revel in the beauty of asynchronous data transducers.</p>

<p>```clojure
(def i-like-them (async/&lt;!! result-chan))</p>

<p>i-like-them
;; &ndash;> &ldquo;I would eat them in the rain.
;;     I would eat them on a train.
;;     I would eat them in a box.
;;     I would eat them with a fox.
;;     I would eat them in a house.
;;     I would eat them with a mouse.
;;     I would eat them here or there.
;;     I would eat them anywhere.&rdquo;</p>

<p>```</p>

<p>Transducers are elegant and powerful, just like the rest of Clojure.  Try them, you will like them :)</p>

<p><img class="<a" src="href="http://ecx.images-amazon.com/images/I/51JqhoQCtgL.jpg">http://ecx.images-amazon.com/images/I/51JqhoQCtgL.jpg</a>"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Proper Pronunciation of Clojure's Assoc]]></title>
    <link href="http://gigasquid.github.io/blog/2014/07/28/the-proper-pronunciation-of-clojures-assoc/"/>
    <updated>2014-07-28T20:27:00-04:00</updated>
    <id>http://gigasquid.github.io/blog/2014/07/28/the-proper-pronunciation-of-clojures-assoc</id>
    <content type="html"><![CDATA[<p>Sometimes I pause before talking to someone about Clojure code. Not because I am unsure of the code, but because I am unsure of
how to pronounce the code.  The particular code in question is
Clojure&rsquo;s <em>assoc</em>.  I have heard it pronounced two ways. One is
&ldquo;assosh&rdquo;, the other is &ldquo;assok&rdquo;.  So, to determine it, I decided to conduct a
scientific poll of the Clojure community.</p>

<p>I posted the poll on
<a href="https://twitter.com/gigasquid/status/493891057906896896">twitter</a> to
the Cojure community who follow me.  The control group poll was not viewed
by those who do not follow me, and/or, are not on twitter.</p>

<p>The results were startling.</p>

<p><img class="<a" src="href="https://c1.staticflickr.com/3/2928/14585605540_6d0ce6169f_n.jpg">https://c1.staticflickr.com/3/2928/14585605540_6d0ce6169f_n.jpg</a>"></p>

<ul>
<li>assosh &ndash; 10</li>
<li>assok  &ndash; 8</li>
<li>assose &ndash; 2</li>
<li>Jeremy &ndash; 1</li>
<li>asoaksh &ndash; 1</li>
</ul>


<p>The community is clearly deeply divided on this important question.</p>

<p>After sifting through the raw data, I remembered my statistical analysis and threw out the extremes.</p>

<p><img class="<a" src="href="https://c2.staticflickr.com/6/5559/14792182503_12aa682260_n.jpg">https://c2.staticflickr.com/6/5559/14792182503_12aa682260_n.jpg</a>"></p>

<p>The conclusion was still a stark reality.</p>

<p><em>We do not as a community know how to pronounce assoc.</em></p>

<h2>Solution</h2>

<p>I can only see one way forward.  We must address this as a community.
I propose that the community documentation of <a href="http://clojuredocs.org/">Clojure Docs</a>
and <a href="http://grimoire.arrdem.com/">Grimoire</a> modify their sites to include audio pronunciation like <a href="http://www.macmillandictionary.com/us/media/british/uk_pron/l/lla/llama/llama_British_English_pronunciation.mp3">this</a>.</p>

<p>Remember, I&rsquo;m pulling for you.  We are all in this together.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure X-Men]]></title>
    <link href="http://gigasquid.github.io/blog/2014/07/27/clojure-x-men/"/>
    <updated>2014-07-27T20:12:00-04:00</updated>
    <id>http://gigasquid.github.io/blog/2014/07/27/clojure-x-men</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://c2.staticflickr.com/6/5557/14761955842_6a8bf4a66a_n.jpg">https://c2.staticflickr.com/6/5557/14761955842_6a8bf4a66a_n.jpg</a>"></p>

<p>Nobody knows how it happened.  Some people think it was due to the rapid expansion and adoption of Clojure.  Other people say that the language itself was caused by something deeper and more magical.  No one knows for sure.  All that we really know is that people starting being born with extraordinary powers.  Powers that no human had had before.  They were strange and unique to each person they touched.  The only thing that they all had in common, was that each was an aspect of the Clojure programming language.</p>

<h2>Luke (AKA Lazy Luke)</h2>

<p>Luke was a teenager when his powers came to him.  His mother always complained that he was lazy.  It was true, he did prefer to sleep until noon.  He also had a habit of putting everything off to the last minute, like saving all his papers for the night before they were due.  One day, though, he noticed something very strange.  He could start to see the future.  Well not really “see” it.  But he could see the infinite possibilities  of the future.  Not very far into the future, but enough.  It was a few milliseconds at first.  But now it was up to a full second.  He checked the Clojure Docs as soon as he realized his gift.  It was lazy evaluation and power to deal with infinite sequences.</p>

<h2>Spress</h2>

<p>Spress, whose real name is Emily, came into her power early.  She was
only 5 years old.  Her mother had taken her to a farm to visit with
the animals.  Her mother had pointed at the cow and told her daughter
that it said “Moo”.  Then, at the horse, saying “Neigh”.  Spress
smiled and  pointed at a bucket and said “cow”.  Her mother shook her head at her, but Spress only smiled bigger.  She said “cow” again.  Then, suddenly, the bucket went “Moo”.  She was immediately taken to the Clojure X-Men school, where they identified her power as protocols.  She trained her power and now is so good at solving the “expression problem”, she is known as “Spress”.</p>

<h2>Multi</h2>

<p>Nobody knows Multi’s background.  He came to notice in his early twenties with his powers.  Ordinary humans process sensory input, (like sight, touch, and sound), in an asynchronous fashion.  However, when it gets processed in the brain, it runs into a single pipeline bottleneck  &ndash; consciousness.  Multi’s power is that he can concurrently process his higher level consciousness and reasoning to all this sensory input.  The result is that he can move, think, and perform super fast  and in a super smart way.
He got the power of Clojure’s concurrency.</p>

<h2>Dot</h2>

<p>Dot always had a way with animals.  She had many pets growing up.  Later, she would go into the forest and the animals would seek her out.  She would be found resting by a tree surrounded by deer and birds.  One time, on her walk, she fell down a ditch and had her leg trapped under a log.  Her mother arrived, after searching for her, to see a Bear reach down and gently remove the log.   She stood dumbfounded, as her daughter thanked the bear and it nodded in reply as it turned away.   She could talk with animals effortlessly.  She had the power of Clojure’s Interop.</p>

<h2>Bob</h2>

<p>Bob is the leader of the Clojure X-Men.  He seeks out people with the
power of Clojure and helps train and educate them.  He also is the
most powerful.  He can come into any argument, problem, or challenge
and immediately separate out what is most important to focus on.  He
always knows the right thing to do, without getting bogged down in
unnecessary details .  His power is Clojure’s simplicity.</p>

<p>There might be others out there, we don’t know.  We can only hope, that they are found by Bob and the Clojure X-Men and use their powers for good.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[World Domination with Hexapods and Clojure]]></title>
    <link href="http://gigasquid.github.io/blog/2014/03/20/world-domination-with-hexapods-and-clojure/"/>
    <updated>2014-03-20T21:00:00-04:00</updated>
    <id>http://gigasquid.github.io/blog/2014/03/20/world-domination-with-hexapods-and-clojure</id>
    <content type="html"><![CDATA[<p>Once you have your <a href="http://gigasquidsoftware.com/blog/2014/03/19/walking-with-hexapods/">hexapod assembled and running using the hand held
controller</a>,
of course, your thoughts naturally turn to world domination.</p>

<h2>The most powerful tool in the world is the Clojure REPL</h2>

<p>World domination requires the most powerful tools available.  That of
course calls for Clojure and the Clojure REPL.  I recommend Emacs
as the editor of choice of such an endeavor.  However, it if you are
content with city, state, or single country domination, other editors
that support Clojure are also fine.</p>

<h2>Connect the XBee to your computer</h2>

<p>First, we need to get the computer to talk to the hexapod wirelessly.
We can do this with a <a href="http://www.trossenrobotics.com/uartsbee">USB to Serial adapter</a>
that uses the paired XBee from the handheld commander.</p>

<p>Take the XBee from the handheld commander</p>

<p><img class="<a" src="href="http://farm4.staticflickr.com/3698/13278059985_f5b5c01819_n.jpg">http://farm4.staticflickr.com/3698/13278059985_f5b5c01819_n.jpg</a>"></p>

<p>and move it to the USB to serial adapter</p>

<p><img class="<a" src="href="http://farm8.staticflickr.com/7067/13298779543_f69a14b42c_n.jpg">http://farm8.staticflickr.com/7067/13298779543_f69a14b42c_n.jpg</a>"></p>

<p>Now plug the usb into your computer.</p>

<h2>Get your Clojure ready</h2>

<p>In your clojure project, the only magic you need is the <a href="https://github.com/samaaron/serial-port">Serial Port library</a>. Import the library and list your serial ports.  Then open the one that shows up for you.</p>

<p>```clojure
(ns clj-hexapod.core
  (require [serial-port :as serial]))</p>

<p>;; Use this command to see what port your serial port
;; is assinged to
(serial/list-ports)</p>

<p>;; replace the USB0 with whater it shows
(def port (serial/open &ldquo;/dev/ttyUSB0&rdquo; 38400))
```</p>

<p>Since we are going to be talking to the hexapod.  We need to send the commands in the same format that it is expecting. Basically, a packet of where the postions of the joystick are, as well as what buttons are pushed.</p>

<p>```clojure
(defn checksum [v]
  (mod (&ndash; 255 (reduce + v)) 256))</p>

<p>(defn vec->bytes [v]
  (byte-array (map #(&ndash;> % (Integer.) (.byteValue) (byte)) v)))</p>

<p>(defn build-packet [r-vert r-horz l-vert l-horz buttons]
  [255 ;header
   r-vert
   r-horz
   l-vert
   l-horz
   buttons
   0
   (checksum [r-vert r-horz l-vert l-horz buttons])])</p>

<p>(defn send [packet]
  (serial/write port (vec->bytes packet)))
```</p>

<p>From here, we can simply make functions for the joystick controls to go up and down</p>

<p>```clojure
;;values between 129-254
(defn up [speed]
  &ldquo;joystick up for speed between 1-100&rdquo;
  (if (good-range? speed)</p>

<pre><code>(int (+ 129 (* 125 (/ speed 100.0))))
CENTER))
</code></pre>

<p>;;values between 0 and 125
(defn down [speed]
  &ldquo;joystick down speed between 1-100&rdquo;
  (if (good-range? speed)</p>

<pre><code>(int (- 125 (* 125 (/ speed 100.0))))
CENTER))
</code></pre>

<p>```</p>

<p>Then we can do things like walk, turn, and change the gait</p>

<p>```clojure
(defn walk-forward [speed]
  &ldquo;walk forward speed between 1-100&rdquo;
  (send (build-packet CENTER CENTER (up speed) CENTER 0)))</p>

<p>(defn walk-backwards [speed]
  &ldquo;walk backwards speed between 1-100&rdquo;
  (send (build-packet CENTER CENTER (down speed) CENTER 0)))</p>

<p>(defn walk-right [speed]
  &ldquo;walk right speed between 1-100&rdquo;
  (send (build-packet CENTER CENTER CENTER (up speed) 0)))</p>

<p>(defn walk-left [speed]
  &ldquo;walk right speed between 1-100&rdquo;
  (send (build-packet CENTER CENTER CENTER (down speed) 0)))</p>

<p>(defn turn-right [speed]
  &ldquo;turn right speed between 1-100&rdquo;
  (send (build-packet CENTER (up speed) CENTER CENTER 0)))</p>

<p>(defn turn-left [speed]
  &ldquo;turn left speed between 1-100&rdquo;
  (send (build-packet CENTER (down speed) CENTER CENTER 0)))</p>

<p>(defn change-gait [gait-key]
  (let [gait-num (gait-key gaits)]</p>

<pre><code>(send (build-packet CENTER CENTER CENTER CENTER gait-num))))
</code></pre>

<p>(defn stop []
  &ldquo;stop hexapod&rdquo;
  (send (build-packet CENTER CENTER CENTER CENTER 0)))
```</p>

<p>You can control it from the REPL with some simple commands</p>

<p><code>clojure
(walk-forward 20)
(walk-backwards 10)
(walk-right 10)
(walk-left 10)
(turn-right 10)
(turn-left 10)
(change-gait :ripple-smooth)
(change-gait :tripod-normal)
(change-gait :ripple)
(change-gait :amble)
(stop)
</code></p>

<p>If you want to see the code, it is out on github as <a href="https://github.com/gigasquid/clj-hexapod">clj-hexapod</a>.  Please keep in mind that it is early days still, and I am still just exploring.</p>

<h2>Phoneix Code Firmware</h2>

<p>It is worth noting the the above code was meant to run with the default hexapod firmware.  That is the &ldquo;Nuke&rdquo; firmware.  There is another firmware, the <a href="https://github.com/KurtE/Arduino_Phoenix_Parts">Phoenix code</a>, that gives the hexapod more lifelike moves and allows it to twist and shift is rather creepy ways.</p>

<p>I just loaded it on the hexapod yesterday.  The commander software changed too, so I will of course need to revisit the code, to add in the new moves.  But here is a sneak preview of what it can do:</p>

<p>
<div class="ratio-4-3 embed-video-container" onclick="var myAnchor = document.getElementById('PmBGt9T-yvI');var tmpDiv = document.createElement('div');tmpDiv.innerHTML = '&lt;iframe style=&quot;vertical-align:top;width:100%;height:100%;position:absolute;&quot; src=&quot;http://www.youtube.com/embed/PmBGt9T-yvI?autoplay=1&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;';myAnchor.parentNode.replaceChild(tmpDiv.firstChild, myAnchor);return false;" title="click here to play">
<a class="youtube-lazy-link" style="width:100%;height:100%;background:#000 url(http://i2.ytimg.com/vi/PmBGt9T-yvI/0.jpg) center center no-repeat;background-size:contain;position:absolute" href="http://www.youtube.com/watch?v=PmBGt9T-yvI" id="PmBGt9T-yvI" onclick="return false;">
<div class="youtube-lazy-link-div"></div>
<div class="youtube-lazy-link-info">Hexapod with Phoenix Code</div>
</a>
<div class="video-info" ></div>
</div>

</p>

<p><em>That is my daughter singing in the background</em></p>

<h2>That&rsquo;s all for now</h2>

<p>I hope I have given you pointers for getting started on your own world domination with Clojure and Hexapods. Remember to practice your laugh &hellip;. Muhahaha :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hitchhiker's Clojure has a New Home]]></title>
    <link href="http://gigasquid.github.io/blog/2014/02/16/hitchhikers-clojure-has-a-new-home/"/>
    <updated>2014-02-16T14:57:00-05:00</updated>
    <id>http://gigasquid.github.io/blog/2014/02/16/hitchhikers-clojure-has-a-new-home</id>
    <content type="html"><![CDATA[<p>The Hitchhiker&rsquo;s Guide to Clojure posts now have a new home to make it
easier to read them in a chronological fashion.</p>

<p><a href="http://hitchhikersclojure.com/">http://hitchhikersclojure.com/</a></p>

<p>There is also a public <a href="https://github.com/gigasquid/hitchhikers-clojure">repo</a> &ndash; feel free to contribute spelling and
grammar fixes, or your great ideas.</p>
]]></content>
  </entry>
  
</feed>

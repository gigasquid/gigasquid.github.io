<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | Squid's Blog]]></title>
  <link href="http://gigasquid.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://gigasquid.github.io/"/>
  <updated>2015-08-20T21:30:35-04:00</updated>
  <id>http://gigasquid.github.io/</id>
  <author>
    <name><![CDATA[Carin Meier]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Conversations with Datomic Part 2]]></title>
    <link href="http://gigasquid.github.io/blog/2015/08/19/conversations-with-datomic-part-2/"/>
    <updated>2015-08-19T08:56:00-04:00</updated>
    <id>http://gigasquid.github.io/blog/2015/08/19/conversations-with-datomic-part-2</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://avatars0.githubusercontent.com/u/1478702?v=3&amp;s=200">https://avatars0.githubusercontent.com/u/1478702?v=3&amp;s=200</a>"></p>

<p><em>The following is a continuation of the first <a href="http://gigasquidsoftware.com/blog/2015/08/15/conversations-with-datomic/">conversation</a> which touched on schema creation and querying.  This conversation includes learning new facts, time, and the sometimes unfortunate reality of lawyers.</em></p>

<p><strong>Human:</strong>  Hi <a href="http://www.datomic.com/">Datomic</a>.  I am back from my tea and cookies break.  I really enjoyed talking with you, could we continue our conversation?</p>

<p><strong>Datomic:</strong> Certainly.  Let me see, where did we leave off?</p>

<p><strong>Human:</strong> Let me check my <a href="https://gist.github.com/gigasquid/92a1effb14fe4f6ced59">notes</a>.  Oh yes, we had created a database and filled it with facts about some dogs and owners.  You showed me how to ask you things about the facts, like which dogs liked cheese.</p>

<p><strong>Datomic:</strong> Ah yes.  We were just getting to the really interesting part about how I learn new facts without forgetting the past ones.</p>

<p><strong>Human:</strong> Can you please explain a bit more about how you learn new facts?</p>

<p><strong>Datomic:</strong> Sure.  I learn facts when you tell me to <em>add</em> a new fact about some entity, or to <em>retract</em> a fact about it.  It will probably make more sense with an example.  Let&rsquo;s take the dog with the name &ldquo;Tiny&rdquo; that I know about.  Could you please ask me about the dog and all of the attributes?</p>

<p><strong>Human:</strong> Alright.</p>

<p><code>clojure
(d/pull (d/db conn) '[*] [:dog/name "Tiny"])
</code></p>

<p><strong>Datomic:</strong></p>

<p><code>clojure
{:db/id 17592186045423
 :dog/name "Tiny"
 :dog/breed "Great Dane"
 :dog/favorite-treat "Cheese"}
</code>
There is an entity (dog) with the name &ldquo;Tiny&rdquo; who is a Great Dane and his favorite-treat is Cheese.  I am not really sure why the Cheese is capitalized, but I am sure it makes sense to a human.</p>

<p><strong>Human:</strong> Oh right.  Well, now that you mention it, I am not really sure about the cheese thing either. Can I just remove that fact?</p>

<p><strong>Datomic:</strong> Well, you can tell me to <em>retract</em> that fact by sending me a transaction in the form of <code>[:db/retract entity-id attribute value]</code>.  In the case of the dog, since the name attribute is unique, you can just give me the selector for Tiny like this <code>[:dog/name "Tiny"]</code>.</p>

<p><strong>Human:</strong> Like this?</p>

<p><code>clojure
(d/transact conn [[:db/retract [:dog/name "Tiny"] :dog/favorite-treat "Cheese"]])
</code></p>

<p><strong>Datomic:</strong> Exactly.  I have retracted that fact about &ldquo;Tiny&rdquo;.  Go ahead and ask me about all of Tiny&rsquo;s attributes again.</p>

<p><strong>Human:</strong>  Ok.  I use <code>(d/db conn)</code> for the current database value right?</p>

<p><strong>Datomic:</strong> Yes. But if you are going to be asking me multiple questions about this database value, you should not repeat the <code>(d/db conn)</code> all the time.</p>

<p><strong>Human:</strong> Oh. What should I do instead?</p>

<p><strong>Datomic:</strong> The connection with me is like a ref.  Just like other refs, you should deref it once to get the database value and then use the value repeatedly. This single database value will provide consistency for all your queries.</p>

<p><strong>Human:</strong> That makes sense.</p>

<p>```clojure
(def db-tiny-no-cheese (d/db conn))</p>

<p>(d/pull db-tiny-no-cheese &lsquo;[*] [:dog/name &ldquo;Tiny&rdquo;])
```</p>

<p><strong>Datomic:</strong></p>

<p><code>clojure
{:db/id 17592186045423, :dog/name "Tiny", :dog/breed "Great Dane"}
</code></p>

<p>Tiny is a Great Dane.</p>

<p><strong>Human:</strong> So you don&rsquo;t know anything about the <code>:dog/favorite-treat</code> for &ldquo;Tiny&rdquo;?</p>

<p><strong>Datomic:</strong> At this particular time, I do not have anything to assert about the favorite-treat of Tiny.  However, I still remember everything about all the facts that you have told me.  For each transaction that you send me, I have a notion of a point in time like <em>t0</em>, <em>t1</em>, <em>t2</em>.  I have a complete database value for each one of those points in time.  In fact, you can look at <em>all</em> of my assertions and retractions that I have learned about using the <code>d/history</code> function on the database value.  This asks me to expose my history, which is normally hidden in favor of the <em>present</em>. I will return back a special database containing all the assertions and retractions across time.  Any queries that you ask me will have a fifth <em>datom</em> field to help you distinguish the difference.</p>

<p><strong>Human:</strong>  A fifth datom field?</p>

<p><strong>Datomic:</strong> A <em>datom</em> consists of the following parts: the entity, the attribute, the value, transaction, and an operation which tells you if the fact was added or retracted (e a v tx op).  Why don&rsquo;t you try using the <code>d/history</code> function to ask me about all the facts having to do with Tiny?  I suggest using the datalog query</p>

<p>```clojure
&lsquo;[:find ?e ?a ?v ?tx ?op
  :in $
  :where [?e :dog/name &ldquo;Tiny&rdquo;]</p>

<pre><code>     [?e ?a ?v ?tx ?op]]
</code></pre>

<p>```</p>

<p>which will return all the entity, attribute, value, transaction, and operation facts I ever knew about Tiny.</p>

<p><strong>Human:</strong> Ok.  Here goes.</p>

<p>```clojure
(d/q &lsquo;[:find ?e ?a ?v ?tx ?op</p>

<pre><code>   :in $
   :where [?e :dog/name "Tiny"]
   [?e ?a ?v ?tx ?op]]
</code></pre>

<p>  (d/history db-tiny-no-cheese))
```</p>

<p><strong>Datomic:</strong></p>

<p>```clojure</p>

<h1>{[17592186045423 63 &ldquo;Tiny&rdquo;       13194139534314 true]</h1>

<p>  [17592186045423 64 &ldquo;Great Dane&rdquo; 13194139534314 true]
  [17592186045423 65 &ldquo;Cheese&rdquo;     13194139534314 true]
  [17592186045423 65 &ldquo;Cheese&rdquo;     13194139534320 false]}
```</p>

<p>During one transaction, you told me to add three facts about an entity:</p>

<ul>
<li>The <code>:dog/name</code> attribute, (which I refer to as 63), has the value of &ldquo;Tiny&rdquo;.</li>
<li>The <code>:dog/breed</code> attribute, (which I refer to as 64), has the value of &ldquo;Great Dane&rdquo;.</li>
<li>The <code>:dog/favorite-treat</code> attribute, (which I refer to as 65), has the value of &ldquo;Cheese&rdquo;.</li>
</ul>


<p>During another transaction, you told me to retract a fact regarding the attribute <code>:dog/favorite-treat</code> about the same entity.</p>

<p><strong>Human:</strong> Wow, that is really cool.  Is there a way that I can <em>travel back in time</em> to see the world as it was during that first transaction?</p>

<p><strong>Datomic:</strong> Yes.  I am practically a Tardis.  You can use the <code>d/as-of</code> function with a database value and the transaction number and you can time travel.  Using that <em>time traveled</em> database value, you can ask me about all the facts I knew as of that time.</p>

<p><strong>Human:</strong> I can&rsquo;t wait to try this.  Ok, let&rsquo;s go back to the time when I first asserted the fact that Tiny liked cheese.</p>

<p><code>clojure
(d/pull (d/as-of db-tiny-no-cheese 13194139534314) '[*] [:dog/name "Tiny"])
</code></p>

<p><strong>Datomic:</strong>  Hold on.  We are time traveling!</p>

<p><code>clojure
{:db/id 17592186045423
 :dog/name "Tiny"
 :dog/breed "Great Dane"
 :dog/favorite-treat "Cheese"}
</code></p>

<p>Tiny is a Great Dane whose favorite treat is Cheese.</p>

<p><strong>Human:</strong> Fantastic! Let&rsquo;s go back to the future now, ummm I mean present. Time is a bit wibbly wobbly.</p>

<p><strong>Datomic:</strong> Just take the <code>as-of</code> function off of the database value and you will be back in the <em>present</em>.</p>

<p><strong>Human:</strong> Hmmm&hellip; Do I have to do a <em>retract</em> every time I want to change a value?  For example, the dog named Fido has a favorite treat of a Bone right now, right?</p>

<p><code>clojure
(d/pull db-tiny-no-cheese '[*] [:dog/name "Fido"])
</code></p>

<p><strong>Datomic:</strong></p>

<p><code>clojure
{:db/id 17592186045421
 :dog/name "Fido"
 :dog/breed "Mix"
 :dog/favorite-treat "Bone"}
</code></p>

<p>Yes, it is a &ldquo;Bone&rdquo;.</p>

<p><strong>Human:</strong> So, if I want to change it to be &ldquo;Eggs&rdquo;,  do I need to retract the current value of &ldquo;Bone&rdquo; first and then add the fact of &ldquo;Eggs&rdquo;?</p>

<p><strong>Datomic:</strong> You certainly could do that and I would understand you perfectly.  However, if you simply assert a new value for an existing attribute, I will automatically add the retraction for you.</p>

<p><strong>Human:</strong> Cool.</p>

<p>```clojure
(d/transact conn [{:db/id [:dog/name &ldquo;Fido&rdquo;]</p>

<pre><code>               :dog/favorite-treat "Eggs"}])
</code></pre>

<p>(d/pull (d/db conn) &lsquo;[*] [:dog/name &ldquo;Fido&rdquo;])
```</p>

<p><strong>Datomic</strong></p>

<p><code>clojure
{:db/id 17592186045421
 :dog/name "Fido"
 :dog/breed "Mix"
 :dog/favorite-treat "Eggs"}
</code></p>

<p>Fido now has a favorite-treat of &ldquo;Eggs&rdquo;.</p>

<p><strong>Human:</strong> This is really neat.  You <em>never</em> forget any facts?</p>

<p><strong>Datomic:</strong> Nope. Well, except in really exceptional circumstances that usually involve lawyers.</p>

<p><strong>Human:</strong> Lawyers?</p>

<p><strong>Datomic:</strong> Sigh.  Yes, well in some unique situations, you might be under a legal obligation to really <em>forget</em> certain facts and totally remove them from the database. There is a special tool that you can use to <em>excise</em> the data.  However, I will store a fact that <em>something</em> was deleted at that time. I just won&rsquo;t be able to remember <em>what</em>.</p>

<p><strong>Human:</strong> That doesn&rsquo;t sound fun.</p>

<p><strong>Datomic:</strong> I prefer to keep all my facts intact.</p>

<p><strong>Human:</strong> I can definitely see that. Well, on a happier subject, I have been very impressed with you during our conversations.  Having a time traveling database that can reason about facts seems like a really useful thing.  Also, you are also really nice.</p>

<p><strong>Datomic:</strong> Awww shucks, thanks.  For a human, you are really nice too.</p>

<p><strong>Human:</strong> I was thinking about the possibility of you coming and working with me every day. Would you mind chatting some more to me about your architecture?  I want to understand how your would fit with our other systems.</p>

<p><strong>Datomic:</strong> Certainly. I would love that.  Do you want to talk about it now, or have another cookie break first?</p>

<p><strong>Human:</strong> Now that you mention cookies&hellip; Let&rsquo;s take a short break and we will talk again soon.</p>

<p><em>(P.S. Humans, there are some great <a href="http://www.datomic.com/training.html">Datomic Training Videos</a> if you want to learn more)</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Conversations with Datomic]]></title>
    <link href="http://gigasquid.github.io/blog/2015/08/15/conversations-with-datomic/"/>
    <updated>2015-08-15T10:29:00-04:00</updated>
    <id>http://gigasquid.github.io/blog/2015/08/15/conversations-with-datomic</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://avatars0.githubusercontent.com/u/1478702?v=3&amp;s=200">https://avatars0.githubusercontent.com/u/1478702?v=3&amp;s=200</a>"></p>

<p><strong>Human:</strong> Hi <a href="http://www.datomic.com/">Datomic</a>.   I have been hearing good things about you.  I would like to talk to you and get to know you.  Is that alright?</p>

<p><strong>Datomic:</strong> Sure!  I would be happy to talk with you.  What language would you like to converse in?</p>

<p><strong>Human:</strong>  I like Clojure.</p>

<p><strong>Datomic:</strong>  That is one of my favorites too.  You know how to setup a Leiningen project right?</p>

<p><strong>Human:</strong> Oh yes.  What dependency should I use?</p>

<p><strong>Datomic:</strong> Just use <code>[com.datomic/datomic-free "0.9.5206"]</code>.</p>

<p><strong>Human:</strong> Got it.  Do you mind if I record our conversation in a namespaced file, so that I can refer back to it later?</p>

<p><strong>Datomic:</strong>  Not a problem.  Make sure to require <code>datomic.api</code> when you set it up.</p>

<p><code>clojure
(ns conversations.datomic
  (require [datomic.api :as d]))
</code></p>

<p><strong>Human:</strong>  All right.  I am all setup up.  I don&rsquo;t really know where to start, so maybe you can tell me a little about yourself.</p>

<p><strong>Datomic:</strong>  I would be happy to.  I am a database of facts.  Would you like to create a database with me?</p>

<p><strong>Human:</strong>  Sure.  How do I do that?</p>

<p><strong>Datomic:</strong> For a casual conversation like this, we can use a in memory database with a uri like this:</p>

<p><code>clojure
(def uri "datomic:mem://first-conversation")
</code>
Then we can create the database and simply connect to it.</p>

<p><code>clojure
(d/create-database uri)
(def conn (d/connect uri))
</code></p>

<p><strong>Human:</strong> So, being a database, obviously you store things.  What sort of things to you store?</p>

<p><strong>Datomic:</strong>  I store facts about things, which I call <em>datoms</em>.</p>

<p><strong>Human:</strong>  That sound neat.  How do I tell you a fact to store?  For example, what if I want you to store a fact about a dog, like its name?</p>

<p><strong>Datomic:</strong>  Ah.  Well the name of a dog is an attribute.  First, you need to tell me about the name attribute, so that I can use it to store the fact for you .  You can describe the attribute in the form of a map like this:</p>

<p><code>clojure
{:db/id (d/tempid :db.part/db)
 :db/ident :dog/name
 :db/valueType :db.type/string
 :db/cardinality :db.cardinality/one
 :db/unique :db.unique/identity
 :db/doc "Name of the Dog"
 :db.install/_attribute :db.part/db}
</code>
 This map is a set of facts, (called <em>datoms</em>),  about an entity.  In this
 case, the entity is an attribute. Attributes, in turn, can be used to describe other entities, like a dog. I will explain the different parts to you.</p>

<ul>
<li><code>db/id</code> is the internal id of the fact. With <code>(d/tempid :db.part/db)</code>, I will generate it for you, so you don&rsquo;t have to worry about it.</li>
<li><code>db/ident</code> is the human readable reference for it. While I am fine just referring to the attribute by an id, humans prefer text.  This says that you can refer to this attribute by the namespaced keyword <code>:dog/name</code>.</li>
<li><code>db/valueType</code> tells me the type of the attribute.  The dog&rsquo;s name is a string.</li>
<li><code>db/cardinality</code> lets me know if there is a one-to-one relationship with the entity or not. In our case, a dog has only one name.</li>
<li><code>db/unique</code> is if that attribute is unique for an entity.  In our example case, we are saying that a dog can be uniquely identified by its name.</li>
<li><code>db/doc</code> is some documentation for humans that explains a bit more about the attribute.</li>
<li><code>db.install/_attribute</code> tells me that this is an schema attribute that I should store with the other things like it.</li>
</ul>


<p><strong>Human:</strong> I think I understand. Let me try one out for myself.  So dog breed would be this?</p>

<p><code>clojure
{:db/id (d/tempid :db.part/db)
 :db/ident :dog/breed
 :db/valueType :db.type/string
 :db/cardinality :db.cardinality/one
 :db/doc "Breed of the Dog"
 :db.install/_attribute :db.part/db}
</code></p>

<p><strong>Datomic:</strong>  Yes!  I think you got it.  Let&rsquo;s try one more.</p>

<p><strong>Human:</strong> Ok.  How about the dog&rsquo;s favorite treat?</p>

<p><code>clojure
{:db/id (d/tempid :db.part/db)
 :db/ident :dog/favorite-treat
 :db/valueType :db.type/string
 :db/cardinality :db.cardinality/one
 :db/doc "Dog's Favorite Treat to Eat"
 :db.install/_attribute :db.part/db}
</code></p>

<p><strong>Datomic:</strong> You got it.  Now, that you have these attributes, you can give them to me using a transaction with the connection.</p>

<p><strong>Human:</strong> Ok.  Do you want that in a specific format?</p>

<p><strong>Datomic:</strong>  Yes.  Please send it to me using the form:</p>

<p><code>clojure
(d/transact conn [....facts....])
</code></p>

<p><strong>Human:</strong> Sounds good.  I will put the dog schema datoms we discussed in a vector and call it <code>dog-schema</code> and then send it to you.</p>

<p>```clojure
(def dog-schema  [{:db/id (d/tempid :db.part/db)</p>

<pre><code>               :db/ident :dog/name
               :db/valueType :db.type/string
               :db/cardinality :db.cardinality/one
               :db/unique :db.unique/identity
               :db/doc "Name of the Dog"
               :db.install/_attribute :db.part/db}
              {:db/id (d/tempid :db.part/db)
               :db/ident :dog/breed
               :db/valueType :db.type/string
               :db/cardinality :db.cardinality/one
               :db/doc "Breed of the Dog"
               :db.install/_attribute :db.part/db}
              {:db/id (d/tempid :db.part/db)
               :db/ident :dog/favorite-treat
               :db/valueType :db.type/string
               :db/cardinality :db.cardinality/one
               :db/doc "Dog's Favorite Treat to Eat"
               :db.install/_attribute :db.part/db}])
</code></pre>

<p>(d/transact conn dog-schema)
```</p>

<p><strong>Datomic:</strong> The transaction was fine.  I know all about those dog attributes now.</p>

<p><strong>Human:</strong>  I would like to also add a schema for owners for the dogs now.  I think I know how to describe the name of the owner, but I don&rsquo;t know how to express how the owner has dogs.</p>

<p><strong>Datomic:</strong> Ah. I that case you can specify the <code>db:valueType</code> as a <code>ref</code> type.  This lets me know that it references another entity.</p>

<p><strong>Human:</strong>  Do I need to tell you that is a type of dog somehow?</p>

<p><strong>Datomic:</strong> No.  I am pretty smart that way.  I will figure it out
  once you try to tell me about some real entities.  In fact, entities don&rsquo;t have types. A ref attribute can reference <em>any</em> entity.</p>

<p><strong>Human:</strong>  Cool.  Well, in that case, here is the owner schema.  The owner has a name and some dogs.</p>

<p>```clojure
(def owner-schema [{:db/id (d/tempid :db.part/db)</p>

<pre><code>                :db/ident :owner/name
                :db/valueType :db.type/string
                :db/cardinality :db.cardinality/one
                :db/unique :db.unique/identity
                :db/doc "Name of the Owner"
                :db.install/_attribute :db.part/db}
               {:db/id (d/tempid :db.part/db)
                :db/ident :owner/dogs
                :db/valueType :db.type/ref
                :db/cardinality :db.cardinality/many
                :db/doc "Dogs of the Owner"
                :db.install/_attribute :db.part/db}])
</code></pre>

<p>(d/transact conn owner-schema)
```</p>

<p><strong>Datomic:</strong>  The transaction is fine.  I now know about the attributes that dogs and owners have.  Would you like to tell me some facts about specific dogs and owners?</p>

<p><strong>Human:</strong>  Yes. Bob is an owner.  He has two dogs. Fluffy is a poodle whose favorite treat is cheese, and Fido is a mixed breed, whose favorite treat is a bone.  Lucy is also an owner who has one dog named Tiny.  Tiny is a Great Dane whose favorite treat is cheese.</p>

<p>I am a bit confused how to represent the dogs of the owners. How do I do that?</p>

<p><strong>Datomic:</strong>  That is easy, just nest the datoms for dogs under the <code>:owner/dogs</code> attribute. You just need to create datoms for them.  Each dog or owner will by its own map.  Use <code>:db/id</code> set to <code>(d/tempid :db.part/user)</code> so I can generate it for you.  Then use each attribute from the schema as the key and let me know the value.</p>

<p><strong>Human:</strong>  Like this?</p>

<p>```clojure
(d/transact conn [{:db/id (d/tempid :db.part/user)</p>

<pre><code>               :owner/name "Bob"
               :owner/dogs [{:db/id (d/tempid :db.part/user)
                             :dog/name "Fluffy"
                             :dog/breed "Poodle"
                             :dog/favorite-treat "Cheese"}
                            {:db/id (d/tempid :db.part/user)
                             :dog/name "Fido"
                             :dog/breed "Mix"
                             :dog/favorite-treat "Bone"}]}
              {:db/id (d/tempid :db.part/user)
               :owner/name "Lucy"
               :owner/dogs [{:db/id (d/tempid :db.part/user)
                             :dog/name "Tiny"
                             :dog/breed "Great Dane"
                             :dog/favorite-treat "Cheese"}]}])
</code></pre>

<p>```</p>

<p><strong>Datomic:</strong>  Exactly right.  I now know the facts about Bob and Lucy and their dogs.</p>

<p><strong>Human:</strong>  Umm, how do I query you about the facts that your know?  For example, how do I ask you about the dog named Tiny?</p>

<p><strong>Datomic:</strong>  There are a couple a ways to inquire about facts I know.  To find out about the attributes of a specific dog, or entity, I would recommend using <code>d/pull</code>.  You can ask me in the form of this to get all the attributes for a given dog name.  Note that this works since the dog name is a way to uniquely identify the dog:</p>

<p><code>clojure
(d/pull (d/db conn) '[*] [:dog/name "Tiny"])
</code></p>

<p><strong>Human:</strong>  What is the <code>(d/db conn)</code> all about?</p>

<p><strong>Datomic:</strong>  That function returns the current database value of the connection. The facts I know change during time.  Every time there is a transaction, I consider the time to be different and there is a new database value.  The <code>d/db</code> function gives you the most recent value that I know about.</p>

<p><strong>Human:</strong> I am assuming the <code>[*]</code> is a wildcard that means give me all the attributes for that dog?</p>

<p><strong>Datomic:</strong>  Exactly right.</p>

<p><strong>Human:</strong> Ok.  Tell me about Tiny.</p>

<p><code>clojure
(d/pull (d/db conn) '[*] [:dog/name "Tiny"])
</code></p>

<p><strong>Datomic:</strong>
<code>clojure
{:db/id 17592186045424
 :dog/name "Tiny"
 :dog/breed "Great Dane"
 :dog/favorite-treat "Cheese"}
</code></p>

<p>Tiny is a Great Dane that has a favorite treat of Cheese.</p>

<p><strong>Human:</strong>  This is fun.  What about more complicated questions.  How do I ask about the name of the owner of the dog &ldquo;Tiny&rdquo;?</p>

<p><strong>Datomic:</strong>  For that I would ask using the <em>datalog</em> query <code>d/q</code>.  It uses logic to unify your query with all of my facts and give you the result.  The query itself would be a vector with logic statements inside like:</p>

<p>```clojure
&lsquo;[:find ?owner-name
  :where [?dog :dog/name &ldquo;Tiny&rdquo;]</p>

<pre><code>     [?owner :owner/dogs ?dog]
     [?owner :owner/name ?owner-name]]
</code></pre>

<p>```</p>

<p><strong>Human:</strong>  Whoa.  What is the deal with those question marks?</p>

<p><strong>Datomic:</strong> The things with the question marks are considered as variables that we will <em>unify</em> to find the answer.  For example, we are looking for something that we are going to call <code>?owner-name</code>. I am going the use the following constraints with my facts to try to find the answer:</p>

<ul>
<li>There is an entity that we are going to call <code>?dog</code> that has the attribute <code>:dog/name</code> that is &ldquo;Tiny&rdquo;</li>
<li>There is an entity that we are going to call <code>?owner</code> that has an attribute <code>:owner/dogs</code> that is the same as the <code>?dog</code> entity</li>
<li>That same <code>?owner</code> entity also has an attribute <code>:owner/name</code> that has the value <code>?owner-name</code></li>
</ul>


<p><strong>Human:</strong>  Alright, so when I ask for this query, do I need to give you a database value too?</p>

<p><strong>Datomic:</strong>  Yes.  They should have the form of:</p>

<p><code>clojure
(d/q '[datalog-query] db-value)
</code></p>

<p>Remember, to get the current db value use <code>(d/db conn)</code>.</p>

<p><strong>Human:</strong>  Ok.  Here we go.</p>

<p>```clojure
(d/q &lsquo;[:find ?owner-name</p>

<pre><code>   :where [?dog :dog/name "Tiny"]
          [?owner :owner/dogs ?dog]
          [?owner :owner/name ?owner-name]]
 (d/db conn))
</code></pre>

<p>```</p>

<p><strong>Datomic:</strong></p>

<p>The answer is:</p>

<p>```clojure</p>

<h1>{[&ldquo;Lucy&rdquo;]}</h1>

<p>```</p>

<p><strong>Human:</strong>  What if I want to pass the dog name as a parameter?  How do I communicate that to you?</p>

<p><strong>Datomic:</strong>  You will need to use an <code>in</code> clause in the query like this:</p>

<p><code>clojure
'[:find [blah]
   :in $ ?dog-name
   :where [blah]]
</code></p>

<p>The $ is shorthand for the database value and the <code>?dog-name</code> is what you will pass in as a parameter in the query after the db-value.</p>

<p><strong>Human:</strong>  Like this?</p>

<p>```clojure
(d/q &lsquo;[:find ?owner-name</p>

<pre><code>   :in $ ?dog-name
   :where [?dog :dog/name dog-name?]
          [?owner :owner/dogs ?dog]
          [?owner :owner/name ?owner-name]]
 (d/db conn) "Tiny")
</code></pre>

<p>```</p>

<p><strong>Datomic:</strong>  Exactly right.  The answer is Lucy again.</p>

<p>```clojure</p>

<h1>{[&ldquo;Lucy&rdquo;]}</h1>

<p>```</p>

<p><strong>Human:</strong>  I think I am getting the hang of this!  Another quick question.  How would I go about asking you which dogs have cheese as their favorite treat?  I would want the dog&rsquo;s name and breed back.</p>

<p><strong>Datomic:</strong>  You would simply construct another datalog query.  This time I would recommend that you combine the <code>pull</code> syntax within the <code>find</code> part of the query.  The <code>pull</code> syntax is great at selecting attributes from an entity.  So the <code>find</code> part would look something like this:</p>

<p><code>clojure
[(pull ?dog [:dog/name :dog/breed]) ...]
</code></p>

<p>This will return the attributes of the <code>:dog/name</code> and the <code>:dog/breed</code>.  The three dots on the end will let me know that you want a collection returned, so I will give you back a simple vector with the entity attributes requested, instead of the set of vectors I normally give back.</p>

<p>The <code>where</code> section of the query is going to look for the <code>?dog</code> entity that matches the <code>:dog/favorite-treat</code> attribute with &ldquo;Cheese&rdquo;.</p>

<p><code>clojure
'[:find [(pull ?dog [:dog/name :dog/breed]) ...]
  :where [?dog :dog/favorite-treat "Cheese"]]
</code></p>

<p><strong>Human:</strong>  Then I put it together with the current database value in a <code>d/q</code> function?</p>

<p>```clojure
(d/q &lsquo;[:find [(pull ?dog [:dog/name :dog/breed]) &hellip;]</p>

<pre><code>   :where [?dog :dog/favorite-treat "Cheese"]]
 (d/db conn))
</code></pre>

<p>```</p>

<p><strong>Datomic:</strong> Yup.  The answer is:</p>

<p><code>clojure
[{:dog/name "Fluffy", :dog/breed "Poodle"}
 {:dog/name "Tiny", :dog/breed "Great Dane"}]
</code></p>

<p><strong>Human:</strong>  Thanks so much.  I think I beginning to get the hang of schemas and queries.  What other things do I need to know about you?</p>

<p><strong>Datomic:</strong>  Well, you have just scratched the surface really.  One of the most interesting things about me is that I never forget facts.  You can add new facts, like Tiny&rsquo;s favorite food is now hotdogs, but I won&rsquo;t forget that he liked cheese at another point in time.</p>

<p><strong>Human:</strong> That sounds really interesting.  I think I need some tea and cookies before I delve into that.  Let&rsquo;s take a short break and talk again soon.</p>

<p><strong>Datomic:</strong>  My pleasure.  I look forward to it.</p>

<p><em>Special thanks to <a href="https://twitter.com/ohpauleez">Paul deGrandis</a> for
the conversation idea :)</em></p>

<p><em>(P.S. Humans, there are some great <a href="http://www.datomic.com/training.html">Datomic Training Videos</a> if you want to learn more)</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Not to Panic While Writing a Clojure Book]]></title>
    <link href="http://gigasquid.github.io/blog/2015/05/22/how-not-to-panic-while-writing-a-clojure-book/"/>
    <updated>2015-05-22T09:11:00-04:00</updated>
    <id>http://gigasquid.github.io/blog/2015/05/22/how-not-to-panic-while-writing-a-clojure-book</id>
    <content type="html"><![CDATA[<p>I made it to that magical moment when the Clojure book I had been working on so long was published and I could actually hold it in my hand.</p>

<p><img class="<a" src="href="https://pbs.twimg.com/media/CDWsQPCUgAERViK.jpg">https://pbs.twimg.com/media/CDWsQPCUgAERViK.jpg</a>"></p>

<p>It was an immense project and I am very happy that it is finally done.  Since then, I met some people that are interested in writing books as well.
They asked if I had any insights or tips having gone through the process as a first time author.  I have collected them in this post in hopes that they will be helpful to those going through the process themselves.</p>

<p>The very first thing to do is to get an outline for your book.</p>

<h3>Start with an Outline</h3>

<p>Ideas are soft and squishy.  They drift into different shapes like clouds, and can melt away just as quickly.  One of the hardest things to do was trying to arrange all those ideas in my head into an initial form that would serve as the structure for the entire book.  I would pick up a pen and paper, start feeling overwhelmed, and suddenly remember I had something else very pressing to do.  I successfully avoided starting a book for quite a while, until one day I cornered myself.  I decided that I write my book outline on a long plane flight.  With salted peanuts as fuel, and nowhere to escape, I finally wrote an outline.  It wasn&rsquo;t perfect but it was a start and looking back and it was not too far off.  Here it is in all of its original roughness.</p>

<p>```
Title: Living Clojure</p>

<p>From beginning steps to thriving in a functional world</p>

<p>(Each Chapter will follow quotes from Alice in Wonderland and very use ideas from some examples)</p>

<p>Book 1 &ndash; Beginner steps</p>

<p>Chapter 1 &ndash; Are you comfortable?  Talk about how OO is comfortable but there is another world out there and new way of thinking functionally.</p>

<pre><code>        White Rabbit goes by
</code></pre>

<p>Chapter 2 &ndash; Forms &amp; Functions &ndash; Falling down the rabbit hole
Chapter 3 &ndash; Functional Transformations &ndash; Growing bigger and smaller &ndash; Key to thinking functionally is about transforming data from one shape to another shape.</p>

<pre><code>        Map &amp; Reduce
</code></pre>

<p>Chapter 4 &ndash; Embracing side effects  &ndash; Clojure is impure functional language (The rabbit&rsquo;s glove)  &ndash; Cover do and io stuff. Also basic stuff about</p>

<pre><code>        STM atoms and agents/ Protocols
</code></pre>

<p>Chapter 5 &ndash; Libraries, Libraries  &ndash; &ndash; how to use Leiningen</p>

<pre><code>        build system. Where to find clojure libraries, how to use
        Serpents - camel-snake-kebab
</code></pre>

<p>Chapter 6 &ndash; core.asyc &ndash; Tea Party introduction to the core.async library
Chapter 7 &ndash; Clojure web &ndash; Chesire cat  &ndash; introduction to Ring, Cheshire library, ClojureScript and OM</p>

<p>Book 2 &ndash; From here to there &ndash; thriving in a functional world</p>

<p>Training plan for thriving in a functional world.</p>

<p>Chapter 8 &ndash; Join the community &ndash; Surround yourself with other Clojure enthusiats
  &ndash; Twitter clojure
  &ndash; Github account
  &ndash; Clojure mailing list
  &ndash; Prismatic clojure news
  &ndash; Meetup for local community group.  If there is not one in your area. start one!
  &ndash; Attend a Clojure conj</p>

<p>Chatpter 9 &ndash; Practice and build up
Like Couch to 5K 7 week training program to work up to
practicing Clojure</p>

<p>```</p>

<p>Now that I had an outline.  I just needed to figure out how long it would take me to write the book.</p>

<h3>However Long You Think It Will Take &ndash; You Are Wrong</h3>

<p>Having never written a book before, I had <em>no idea</em> how much work it would be.  The closest thing I had to compare it to was writing a blog post.  I figured writing a chapter would be roughly equivalent to writing a blog post.  If I could go back in time, this is the moment where my future self would pour a glass of ice water on my past self.  Writing a book is nothing like that.  It is a lot of time and work.  If I <em>had</em> to compare it now to writing blog posts, the process would be this.</p>

<pre><code>- You write a blog post.
- You rewrite the blog post.
- You write a second blog post.
- You rewrite that blog post and the first one too.
- You write another blog post.
- You rewrite all three post .....
</code></pre>

<p>So, if you have to commit to deadlines, make sure you remember how hard it will be, and then double the number.</p>

<p>Speaking of deadlines, they suck, but you should have them.</p>

<h3>Make Deadlines</h3>

<p>Deadlines are not fun.  In fact, deadlines might even be a source of potential panic.  But for me, they were necessary evil.  There were a few beautiful times when inspiration came knocking at my door and I couldn&rsquo;t wait to start writing.  But most of the time, inspiration was off somewhere else eating biscuits.  The only thing that actually moved the book along was me knowing that I needed to get the next chunk done by a certain date.</p>

<p>I found the best thing to do was to set aside a small bit of time on a daily basis to write something.</p>

<h3>Routine, Routine, Routine</h3>

<p>A daily routine was the most crucial thing for me.  Life is really busy with work and family.  It is so easy to get overwhelmed with daily life.  I decided that mornings would work best for me.  So I would stumble in to my computer an hour before work, with a hot cup of tea in hand, and write something.  Some days I actually did quite a bit.  Other days, I would write one sentence and declare it done.  But, I would always do <em>something</em>.  Even though those small slices of time didn&rsquo;t seem like a lot, they added up over the course of a week.</p>

<p>Another curious thing happens when you do something, even a little bit, day after day.  You start to get better at it.</p>

<h3>Writing is a Different Skill from Coding</h3>

<p>I was used to writing code all day.  I found that the code writing skills are not the same as writing about code.  In fact, I found it really hard to do at the start.  But, just like writing code, you get better with practice.  And to get better at anything, feedback is really important.</p>

<h3>Get and Trust Feedback</h3>

<p>After each chapter, I would get feedback from my editor.  She was awesome and provided ways for me to improve the experience for the reader.  I lost track of how many times I rewrote that first chapter, but each time it would get a bit better and I would improve as well.  After the book was about half done it was sent out to others for technical review.  They provided feedback not only on the writing style but also the technical content, making sure that it all made sense.</p>

<p>The feedback loop is much slower for writing a book than writing code, but it is just as vital.  The great people providing feedback are you closest partners in this.  You need to trust them.  Especially during the roughest time, the middle of the book.</p>

<h3>The Middle Bit is the Hardest</h3>

<p>I found the hardest time was about halfway through the book.  The initial excitement of the new endeavor had long since worn off.  It seemed like such a mountain of a task, with no end in sight.  I questioned my decision to continue with it daily.  My routine and deadlines kept me moving forward.  But my circle of friends and family kept me sane.  It was great to have an outlet, not only to vent my frustration with my slow progress, but to get kind encouragement to keep my spirits up.</p>

<p>During these dark days, I also ate cheese.</p>

<h3>Celebrate Your Small Victories</h3>

<p>At the end of every chapter or deadline I would fix myself a nice plate of cheese and crackers.  You have to celebrate the small wins.  Cheese is also very tasty.</p>

<p>When the book was finally done.  I had a really tasty plate, complete with Stilton, Brie, and a dependable Cheddar.  I was incredibly happy to be finished. But I knew that I definitely could have not done it without the help of others.</p>

<h3>Thank Everyone that Supported You</h3>

<p>Writing a book is a huge undertaking that is utterly impossible to do alone.  I could have not done it without the help and support of my editor, reviewers, family, friends, as well as the entire Clojure Community.  I am so thankful to all of you that helped my in this project.  You are great.</p>

<p>So, should you go ahead and write that book?</p>

<h3>Do It</h3>

<p>Yes, you should write that book and share your knowledge.  Don&rsquo;t panic, remember to breathe, get some cheese and tea, and go for it!  It will be awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Partition with Game of Thrones Pugs]]></title>
    <link href="http://gigasquid.github.io/blog/2015/01/26/partition-with-game-of-thrones-pugs/"/>
    <updated>2015-01-26T18:55:00-05:00</updated>
    <id>http://gigasquid.github.io/blog/2015/01/26/partition-with-game-of-thrones-pugs</id>
    <content type="html"><![CDATA[<p>Clojure&rsquo;s <em>partition</em> and <em>partition-all</em> functions are very useful.
However, I have been bitten a few times using <em>partition</em> when I
really wanted <em>partition-all</em>.  So to help myself and all of you to
remember it, I have made some diagrams with <a href="http://www.designswan.com/archives/the-pugs-of-westeros-cute-pugs-dressed-up-like-characters-in-game-of-thrones.html">pugs from the Game of Thrones</a></p>

<p>In code, <a href="http://clojuredocs.org/clojure.core/partition">partition</a> takes a collection and returns a lazy sequence of
lists, each containing n items.</p>

<p>To demonstrate this with pugs, we will partition 5 pugs into groups of
twos.</p>

<p><img class="<a" src="href="https://c4.staticflickr.com/8/7301/15757758964_570d260a31_c.jpg">https://c4.staticflickr.com/8/7301/15757758964_570d260a31_c.jpg</a>"></p>

<p>This partition will give you two groups of two pugs.</p>

<p><img class="<a" src="href="https://c4.staticflickr.com/8/7350/16380203235_91c8c4e9ee_c.jpg">https://c4.staticflickr.com/8/7350/16380203235_91c8c4e9ee_c.jpg</a>"></p>

<p>Notice, (and here is the important part), the last pug is missing.  The Joffrey pug is not included because <em>partition</em> will not include items that do not make a complete partition.  In this case, because there is no group of 2 pugs for the Joffrey pug to be in, it gets dropped.</p>

<p><em>This is the thing that has bitten me in the past.</em></p>

<p>A common use for wanting to partition things is to control the number
of things that you process at one time.  An example of this is sending only 500 items to be processed in a batch job at one time.  If you have a few thousand items to be processed, partitioning them is a good way of chuncking.  However, if you have an arbitrary number of items, you most certainly want to process them <em>all</em> and not drop any.  This is where you should use <em>partition-all</em> instead.</p>

<p><a href="http://clojuredocs.org/clojure.core/partition-all">Partition-all</a> chunks the items as well, but also includes any leftovers.  Demonstrating again with pugs.</p>

<p><img class="<a" src="href="https://c4.staticflickr.com/8/7427/15757758884_20bfd014eb_c.jpg">https://c4.staticflickr.com/8/7427/15757758884_20bfd014eb_c.jpg</a>"></p>

<p>This <em>partition-all</em> will give you three groups of pugs.</p>

<p><img class="<a" src="href="https://c4.staticflickr.com/8/7323/16193980179_229343f7f3_c.jpg">https://c4.staticflickr.com/8/7323/16193980179_229343f7f3_c.jpg</a>"></p>

<p>This time pug Joffrey is not left out!</p>

<p>Remember, think carefully before using <em>partition</em>.  Don&rsquo;t leave a pug out.</p>

<p>By the way, I can&rsquo;t wait till the next season of Game of Thrones.  Until then ..</p>

<p>
<div class="ratio-4-3 embed-video-container" onclick="var myAnchor = document.getElementById('2EoQCtPR2-I');var tmpDiv = document.createElement('div');tmpDiv.innerHTML = '&lt;iframe style=&quot;vertical-align:top;width:100%;height:100%;position:absolute;&quot; src=&quot;http://www.youtube.com/embed/2EoQCtPR2-I?autoplay=1&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;';myAnchor.parentNode.replaceChild(tmpDiv.firstChild, myAnchor);return false;" title="click here to play">
<a class="youtube-lazy-link" style="width:100%;height:100%;background:#000 url(http://i2.ytimg.com/vi/2EoQCtPR2-I/0.jpg) center center no-repeat;background-size:contain;position:absolute" href="http://www.youtube.com/watch?v=2EoQCtPR2-I" id="2EoQCtPR2-I" onclick="return false;">
<div class="youtube-lazy-link-div"></div>
<div class="youtube-lazy-link-info"></div>
</a>
<div class="video-info" ></div>
</div>

</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure FizzBuzz without Conditionals]]></title>
    <link href="http://gigasquid.github.io/blog/2014/11/13/clojure-fizzbuzz-without-conditionals/"/>
    <updated>2014-11-13T21:43:00-05:00</updated>
    <id>http://gigasquid.github.io/blog/2014/11/13/clojure-fizzbuzz-without-conditionals</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://c1.staticflickr.com/5/4136/4825113119_9630b7927f.jpg">https://c1.staticflickr.com/5/4136/4825113119_9630b7927f.jpg</a>"></p>

<p>Sure you may have done FizzBuzz before.  Maybe you have even done it
in Clojure.  But have you done it without the use of <em>any</em>
conditionals?</p>

<p>As your brain starts to work on the <em>how</em> this we be done, you might
be wondering <em>why</em> you should do this in the first place?</p>

<p>There are two very good reasons for this.  The first is that it is a
<em>kata</em>.</p>

<h2>Katas build your code practice</h2>

<p><img class="<a" src="href="https://c4.staticflickr.com/4/3552/3434757877_711709da58_b.jpg">https://c4.staticflickr.com/4/3552/3434757877_711709da58_b.jpg</a>"></p>

<p>Code katas build your skill through practice.  It doesn&rsquo;t matter if
you are a beginner or an expert.  Just, like in all those martial arts
movies with the swordsman practicing, so must we.  We stretch and
flex our coding muscles with katas to grow them and keep them in shape.</p>

<p>Yes, you may code every day at work.  But it is not the same as kata
practice.  So much of <em>day to day</em> work involves complexity
with large interconnected concerns.  Our  kata practice cuts the extra
complexity out and leaves you alone with a focused small problem.</p>

<p>The second reason involves why you
should try it, this time,  <em>without conditionals</em>.  The answer is <em>creativity</em>.</p>

<h2>Constraints build creativity.</h2>

<p>It turns out that constraints are a
<a href="http://www.forbes.com/sites/groupthink/2013/07/12/creativity-how-constraints-drive-genius/">key way to drive creativity</a>.
Programming does not only require technical skills, but also
creativity. We are seldom asked to build software without constraints.
It drives design.  Sure, it can be annoying when we have to communicate with
a server that is only active on Tuesday and emits its response in
Morse Code.  But it gives us boundaries to unleash our creative
spirit.</p>

<p>So go for it.</p>

<h2>Give it a try</h2>

<p>Ready?  Here are the details.</p>

<ul>
<li>Given a number, if it number is divisible by 3 return &ldquo;fizz&rdquo;.</li>
<li>If it is divisible by 5 return &ldquo;buzz&rdquo;.</li>
<li>If it is divisible by 3 and 5 return &ldquo;fizzbuzz&rdquo;.</li>
<li>Otherwise, just return the number.</li>
<li>Don&rsquo;t use any conditionals like <em>if</em> <em>else</em> <em>case</em> <em>cond</em>.</li>
</ul>


<p>When you are done, you can check out some of the other solutions. Try
not to peek until you have done your version first though.</p>

<p>(There are some really awesome ones so far).</p>

<p><em>Feel free to link to yours in the comments too</em> :)</p>

<h2>Solutions</h2>

<p><a href="https://twitter.com/adereth/status/530740818420957184">From @aderth</a></p>

<p><a href="https://twitter.com/IamDrowsy/status/530900853855899648">From @IamDrowsy</a></p>

<p><a href="https://twitter.com/bryanwoods/status/530822584963584000">From @Bryanwoods</a></p>

<p><a href="https://twitter.com/defndaines/status/532368201472950272">From @defndaines</a></p>

<p><a href="https://gist.github.com/gigasquid/dc4686e8245154482be8">From <em>me</em></a></p>

<p><a href="https://twitter.com/hyPiRion/status/530718638064828416">From @hyPiRion</a> &ndash;
a couple of notes for this one is that:</p>

<p><code>clojure
(+)
;; -&gt; 0
</code>
and</p>

<p><code>clojure
(*)
;; -&gt; 1
</code></p>

<p>And once you think about that, you might want to read <a href="https://gist.github.com/igstan/c3797e51aa0784a5d275">this</a> :)</p>

<p>Happy Clojure Kataing!</p>
]]></content>
  </entry>
  
</feed>
